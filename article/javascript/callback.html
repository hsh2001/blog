<!DOCTYPE html>
<!-- Copyright (c) 2018 "Seung-hyun Hwang" All Rights Reserved. -->
<html lang="ko" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, viewport-fit=cover">

    <title>개발자국: JavaScript, Callback function.</title>

    <link href="https://fonts.googleapis.com/css?family=Nanum+Gothic" rel="stylesheet">
    <link rel="stylesheet" href="/blog/assets/css/global/reset.css">
    <link rel="stylesheet" href="/blog/assets/css/global/content.css">
    <link rel="stylesheet" href="/blog/assets/css/global/button.css">
    <link rel="stylesheet" href="/blog/assets/css/global/body.css">
    <link rel="stylesheet" href="/blog/assets/css/global/article.css">
    <link rel="stylesheet" href="/blog/assets/css/global/header.css">
    <link rel="stylesheet" href="/blog/assets/css/global/nav.css">
    <link rel="stylesheet" href="/blog/assets/css/global/footer.css">
    <link rel="stylesheet" href="/blog/assets/css/global/disqus.css">

    <link rel="stylesheet" href="/blog/assets/css/article/code/javascript.css">

    <script src="//cdn.jsdelivr.net/npm/promise-polyfill@8/dist/polyfill.min.js"></script>
    <script src="/blog/assets/js/global/ajax.js"></script>
    <script src="/blog/assets/js/global/query.js"></script>
    <script src="/blog/assets/js/global/header.js"></script>
    <script src="/blog/assets/js/global/menu.js"></script>
    <script src="/blog/assets/js/global/blog_title.js"></script>
    <script src="/blog/assets/js/global/footer.js"></script>
  </head>
  <body>
    <header>로딩중...</header>
    <nav>로딩중...</nav>

    <div id=blog-title></div>
    <div class="main-title">콜백 함수(Callback function), "그때 부를게!"</div>
    <article class="rounded shadow">
      <p class="title">Callback?</p>
      <img
        class="icon"
        src="/blog/img/article/javascript/callback/iconmonstr-phone-12-240.png"
        alt="전화">
      <p>
        아직 완성되지 않은 게시글입니다.
        부족한 설명 또는 잘못된 정보에 유의해주세요.
      </p>
      <p>
        사전적 의미로의 Callback은,
        "다른 코드의 인수로서 넘겨주는 실행 가능한 코드"
        (출처: <a target="_blank" href="https://ko.wikipedia.org/wiki/콜백">위키백과</a>)
        를 뜻한다.
        <del>이 말이 뭔지 이해했으면 이 글을 열었을 리가 없다.</del>
        조금 쉽게 말하자면 함수에 다른 (또는 같은) 함수를 인수로서
        넣어 <b>나중에 호출</b>할 수 있음을 뜻한다.
      </p>
      <p>
        자바스크립트로 a.txt라는 파일의 내용을 읽어와서
        사용자에게 보여주는 코드를 작성한다고 가정해보자.
        브라우저에서
        a.txt의 내용을 서버에게 요청하면
        응답을 기다리기까지의 대기시간이 발생한다.
        대기시간이 5초라고 가정하면,
        자바스크립트는 싱글스레드 언어이기 때문에
        요청을 하고 응답을 받는 5초 동안은 아무런 동작도 할 수 없게 된다.
        이러한 문제점은 해당 코드가 동기 방식으로 작성되었기 때문이며,
        실제로는 비동기 방식의 코드를 주로 작성한다.
        서버에게 비동기 요청을 하는 f라는 함수가 있을 때,
        응답을 받은 시점에 다시 호출할 함수를 g로 정의하면
        이때의 함수 g를 <b>콜백함수</b>라고 한다.
        동기와 비동기에 대해서는 아래에서 다시 한번 언급한다.
      </p>

      <p class="title">함수 선언식과 함수 표현식.</p>
      <img
        class="icon"
        src="/blog/img/article/javascript/callback/iconmonstr-school-6-240.png"
        alt="칠판">
      <p>
        본격적으로 콜백에 대해 알아보기 전에,
        자바스크립트의 함수와 다른 프로그래밍 언어의 함수와의
        차이점에 대해 알아보자.
        자바스크립트의 함수는 다른 언어와 다르게
        변수에 대입할 수 있는 <b>값</b>으로 취급한다.
        이에따라 함수를 초기화하는 방식은
        '함수 선언식'과 '함수 표현식'으로 나뉜다.
      </p>
      <code class=javascript>
<span class=comment>//함수 선언식.
//함수를 선언함.
</span><span class=keyword>function</span> <span class=function>funcName</span>(<span class=var>param</span>) {
  <span class=comment>//코드...</span>
}
      </code>
      <code class=javascript>
<span class=comment>//함수 표현식
//함수를 변수에 대입함.</span>
<span class=keyword>var</span> <span class=function>funcName</span> = <span class=keyword>function</span> (<span class=var>param</span>) {
  <span class=comment>//코드...</span>
}
      </code>
      <p>
        두 변수의 범위와 호이스팅 등의 몇 특징을
        제외하고는 대체로 같은 동작을 하는 코드다.
        이외의 함수 선언식과 함수 표현식의 차이점은
        이 글에 주제에 벗어나기에
        다음에 다뤄보도록 하자.
        우리가 주목해야 할 것은 함수 표현식이다.
        (물론 함수 선언식으로도 설명할 수도 있다.)
      </p>
      <p>
        <b>함수를 변수에 대입</b>하는 행위가 가능하다는 것은
        다음과 같이
        f라는 함수의 인수로서 g라는 함수를 넘겨줄 수 있다는 뜻이다.
      </p>
      <code class="javascript">
<span class=function>f</span>(<span class=keyword>function</span> <span class=function>g</span>(<span class=var>param</span>) {
  <span class=comment>//코드...</span>
});
      </code>
      <p>
        조금 어려우니 실제 콜백함수의 예제로 살펴보자.
      </p>

      <p class="title">예제 1. setTimeout 함수.</p>
      <img
        class="icon"
        src="/blog/img/article/javascript/callback/iconmonstr-time-6-240.png"
        alt="시간">
      <p>
        "스크립트를 실행했다가 1초만 쉴 수는 없을까?"
      </p>
      <p>
        가능하다.
        자바스크립트 내장함수인 setTimeout 이다.
        이 함수는 두 개의 인수를 기대하는데,
        첫 번째 인수는 함수,
        두 번째 인수는 음이 아닌 실수이다.
        두 번째로 받은 인수만큼의 시간 후에
        첫 번째 인수로 받은 함수를 호출한다.
        (이때, 시간의 단위는 ms(밀리 세컨드)이며, 1ms = 1/1000초이다.)
      </p>
      <code class=javascript>
<span class=comment>//  3000ms(3초) 후에 Hello world!를 경고창에 띄움.</span>
<span class=function>setTimeout</span>(<span class=keyword>function</span> () {
  <span class=function>alert</span>(<span class=string>"Hello world!"</span>);
}, <span class=number>3000</span>);
      </code>
      <p>
        물론 (웹브라우저 자바스크립트를 기준으로)
        전역변수 alert에는 함수가 할당되어 있으므로
        다음과 같은 코드도 유효하다.
        함수에 인자로 함수를 줄 때
        함수 표현식만 사용 가능한 것이 아님을 증명한다.
      </p>
      <code class=javascript>
<span class=comment>//  3000ms(3초) 후에 undefiend를 경고창에 띄움.</span>
<span class=function>setTimeout</span>(<span class=var>alert</span>, <span class=number>3000</span>);
      </code>
      <p>
        하지만 대부분의 콜백함수는
        콜백되는 시점에만 호출되는 패턴이 많아서
        대체로 함수 표현식이 주로 사용되는 편이다.
      </p>

      <p class="title">예제 2. window.onload</p>
      <img
        class="icon"
        src="/blog/img/article/javascript/callback/iconmonstr-loading-10-240.png"
        alt="로딩">
      <p>
        웹 개발자라면 자주 보았을 window.onload 이다.
        (window.addEventListener의 사용을 권장하지만
        이 글에서는 단순 예제를 위한 것이므로
        window.onload를 사용함.)
      </p>
      <code class=javascript>
<span class=comment>//로딩이 끝난 시점에
//body 태그의 글씨 색을 빨간색으로 함.</span>
<span class=var>window</span>.<span class=function>onload</span> = <span class=keyword>function</span> () {
  <span class=var>document</span>.<span class=var>body</span>.<span class=var>style</span>.<span class=var>color</span> = <span class=string>'red'</span>;
}
      </code>
      <p>
        만약 head 태그 안에 있는 저 자바스크립트 코드가
        onload 함수 안에 있지 않고 함수 밖에서 실행된다면,
        저 코드가 실행될 시점에 body 태그는 로드되지 않았으므로
        body 태그에 접근하지 못해 에러를 낼 것이다.
        그러므로 body 태그에 접근하여 작동하는 코드는
        로딩이 끝난 시점에 실행해달라고
        브라우저에게 부탁한 셈이다.
      </p>

      <p class="title">예제 3. document.onclick</p>
      <img
        class="icon"
        src="/blog/img/article/javascript/callback/iconmonstr-cursor-7-240.png"
        alt="마우스 커서">
       <code class=javascript>
<span class=comment>//대상을 클릭하면 알림을 줌.</span>
<span class=var>document</span>.<span class=function>getElementById</span>(<span class=string>'target'</span>).<span class=function>onclick</span> = <span class=keyword>function</span> () {
  <span class=function>alert</span>(<span class=string>"당신은 대상을 클릭하였습니다!!!"</span>);
}
      </code>
      <p>
        2번 예제와 비슷하게,
        대상을 클릭하였을 때 함수가 호출되며 알림을 준다.
        다른 점이라면 onload는 페이지 로딩이 끝난 시점에
        한 번만 실행되지만
        onclick은 클릭할 때마다,
        즉, 클릭한 횟수만큼 호출되는 것이다.
      </p>

      <p class="title">예제 4. Array.prototype.forEach</p>
      <img
        class="icon"
        src="/blog/img/article/javascript/callback/iconmonstr-redo-3-240.png"
        alt="순환">
      <p>
        배열은 그 특성상 순회하며 데이터를 처리하는 작업을 많이 한다.
        때문에 자체적으로 그러한 메소드를 지원하는데,
        유용한 메소드 중 하나인 forEach 또한 콜백 패턴이 사용된다.
        forEach 메소드의 기본형은 다음과 같다.
      </p>
      <code>arr.forEach(callback[, thisArg]);</code>
      <p>
        (thisArg는 무시해도 좋다.)
        첫 번째 인자 callback은 이름 그대로 함수를 기대한다.
        이렇게 받은 함수를 배열의 각 원소를 순회하며 호출한다.
        아래와 같은 코드는 콘솔에 2001, 5, 20을 출력한다.
      </p>
      <code class="javascript">
        [<span class="number">2001</span>, <span class="number">5</span>, <span class="number">20</span>].<span class="function">forEach</span>(<span class="var">console</span>.<span class="var">log</span>);
      </code>

      <p class="title">콜백헬 (Callback Hell)</p>
      <img
        class="icon"
        src="/blog/img/article/javascript/callback/iconmonstr-script-11-240.png"
        alt="잘못된 스크립트">
      <p>
        콜백헬, 콜백 지옥이라고 불리는 자바스크립트의 코드 형태는,
        콜백함수가 여러번 중첩되며 함수로 인한
        들여 쓰기가 많아져서 코드의 가독성을 해치는 경우다.
        아래의 코드는
        1초 후에 1을 콘솔에 찍고,
        그로부터 1초 후에 2를 콘솔에 찍고,
        그로부터 1초 후에 3을 콘솔에 찍고,
        그로부터 1초 후에 4를 콘솔에 찍는 코드다.
      </p>
      <code class=javascript>
<span class=function>setTimeout</span>(<span class=keyword>function</span> () {
  <span class=var>console</span>.<span class=function>log</span>(<span class=number>1</span>);
  <span class=function>setTimeout</span>(<span class=keyword>function</span> () {
    <span class=var>console</span>.<span class=function>log</span>(<span class=number>2</span>);
    <span class=function>setTimeout</span>(<span class=keyword>function</span> () {
      <span class=var>console</span>.<span class=function>log</span>(<span class=number>3</span>);
      <span class=function>setTimeout</span>(<span class=keyword>function</span> () {
        <span class=var>console</span>.<span class=function>log</span>(<span class=number>4</span>);
      }, <span class=number>1000</span>);
    }, <span class=number>1000</span>);
  }, <span class=number>1000</span>);
}, <span class=number>1000</span>);
      </code>
      <p>
        코드가 구부러진 마냥 이상한 형태를 보인다.
        이러한 코드는 가독성을 해치기 쉽다.
        이러한 코드의 해결방안은 다음과 같다.
      </p>
      <p class=center><b>1. 논리적으로 분해한다.</b></p>
      <p>
        위와 같은 코드는 n초 후에 n을 콘솔에 찍는다.
        그러므로 난잡하게 함수 안에 넣을 필요 없이 아래와 같이
        여러 번 setTimeout 함수를 호출해 해결할 수 있다.
      </p>
      <code class=javascript>
<span class=function>setTimeout</span>(<span class=keyword>function</span> () {
  <span class=var>console</span>.<span class=function>log</span>(<span class=number>1</span>);
}, <span class=number>1000</span>);
<span class=function>setTimeout</span>(<span class=keyword>function</span> () {
  <span class=var>console</span>.<span class=function>log</span>(<span class=number>2</span>);
}, <span class=number>2000</span>);
<span class=function>setTimeout</span>(<span class=keyword>function</span> () {
  <span class=var>console</span>.<span class=function>log</span>(<span class=number>3</span>);
}, <span class=number>3000</span>);
<span class=function>setTimeout</span>(<span class=keyword>function</span> () {
  <span class=var>console</span>.<span class=function>log</span>(<span class=number>4</span>);
}, <span class=number>4000</span>);
<span class=comment>//반복문을 이용하여도 좋다.</span>
      </code>
      <p>
        하지만 아쉽게도 이렇게 간단히 분리되는 경우는 드물다.
        콜백함수가 호출되어야 할 시점이 정해져있기 때문인데,
        만약 서버의 응답을 받고 3초 뒤에
        콘솔에 알림을 주려면 이야기는 달라진다.
        접속자의 인터넷 환경이 좋아 0.5초 만에
        응답을 받았다면 콘솔 알림은 3.5초 뒤에
        나와야 한다.
        반대로 접속자의 인터넷 환경이 좋지 않아
        10초 동안 응답을 대기했다가 받았다면
        콘솔 알림은 13초 뒤에 나와야 한다.
        아래부터는 f(g)라는 비동기 코드에서
        콜백함수 g가 호출된 이후에 실행할 내용이 있을 경우이다.
      </p>
      <p class=center><b>2. 함수로 분리한다.</b></p>
      <p>
        자주 애용되는 패턴이다.
        각각의 함수들이 서로를 호출하는 형식이다.
      </p>
      <code class=javascript>
<span class=function>log1</span>();

<span class=keyword>function</span> <span class=function>log1</span> () {
  <span class=var>console</span>.<span class=function>log</span>(<span class=number>1</span>);
  <span class=function>setTimeout</span>(<span class=var>log2</span>, <span class=number>1000</span>);
}

<span class=keyword>function</span> <span class=function>log2</span> () {
  <span class=var>console</span>.<span class=function>log</span>(<span class=number>2</span>);
  <span class=function>setTimeout</span>(<span class=var>log3</span>, <span class=number>1000</span>);
}

<span class=keyword>function</span> <span class=function>log3</span> () {
  <span class=var>console</span>.<span class=function>log</span>(<span class=number>3</span>);
  <span class=function>setTimeout</span>(<span class=var>log4</span>, <span class=number>1000</span>);
}

<span class=keyword>function</span> <span class=function>log4</span> () {
  <span class=var>console</span>.<span class=function>log</span>(<span class=number>4</span>);
}
      </code>
      <p class=center><b>3. Promise, async & await 사용.</b></p>
      <p>
        비교적 최신에 나온 문법이며 난이도가 조금 있는 문법이다.
        이에 대한 자세한 내용은 이 글에서는 다루지 않는다.
      </p>
      <code class=javascript>
<span class=comment>//Promsie만 사용.</span>

<span class=keyword>function</span> <span class=function>wait</span>(<span class=var>ms</span>) {
  <span class=keyword>return new</span> <span class=constructor>Promise</span>(
    <span class=var>resolve</span> => <span class=function>setTimeout</span>(<span class=var>resolve</span>, <span class=var>ms</span>)
  );
}

<span class=constructor>Promise</span>.<span class=function>resolve</span>()
.<span class=function>then</span>(<span class=keyword>function</span> () {
  <span class=var>console</span>.<span class=function>log</span>(<span class=number>1</span>);
  <span class=keyword>return</span> <span class=function>wait</span>(<span class=number>1000</span>);
})
.<span class=function>then</span>(<span class=keyword>function</span> () {
  <span class=var>console</span>.<span class=function>log</span>(<span class=number>2</span>);
  <span class=keyword>return</span> <span class=function>wait</span>(<span class=number>1000</span>);
})
.<span class=function>then</span>(<span class=keyword>function</span> () {
  <span class=var>console</span>.<span class=function>log</span>(<span class=number>3</span>);
  <span class=keyword>return</span> <span class=function>wait</span>(<span class=number>1000</span>);
})
.<span class=function>then</span>(<span class=keyword>function</span> () {
  <span class=var>console</span>.<span class=function>log</span>(<span class=number>4</span>);
});
      </code>
      <code class=javascript>
<span class=comment>//async await keyword 사용.</span>

<span class=function>logNumbers</span>();

<span class=keyword>function</span> <span class=function>wait</span>(<span class=var>ms</span>) {
  <span class=keyword>return new</span> <span class=constructor>Promise</span>(
    <span class=var>resolve</span> => <span class=function>setTimeout</span>(<span class=var>resolve</span>, <span class=var>ms</span>)
  );
}

<span class=keyword>async function</span> <span class=function>logNumbers</span>() {
  <span class=keyword>for</span> (<span class=keyword>let</span> <span class=var>i</span> = <span class=number>1</span>; <span class=var>i</span> <span class=operator><=</span> <span class=number>4</span>; <span class=var>i</span><span class=operator>++</span>) {
    <span class=var>console</span>.<span class=function>log</span>(<span class=var>i</span>);
    <span class=keyword>await</span> <span class=function>wait</span>(<span class=number>1000</span>);
  }
}
      </code>

      <p class=title>마치며</p>
      <img
        class="icon"
        src="/blog/img/article/javascript/callback/iconmonstr-link-1-240.png"
        alt="링크">
      <p>
        자바스크립트에서 콜백함수는 빠질 수 없는 존재이다.
        하지만 위에서 보았던 콜백헬 등 여러 가지
        불편한 점도 가지고 있는데,
        이러한 문제를 해결하기 위해 등장한 문법이
        Promise와 async await 키워드이다.
        이에 대한 내용은 다음 글에서 다뤄보도록 하자.
      </p>
    </article>
    <a href="/blog" class="long button">홈</a>
    <a href="./" class="long button">글 목록</a>

    <br>
    <p class="glass-bg rounded shadow center box-title">커뮤니티</p>
    <div id="disqus_thread">로딩중..</div>
    <script async src="../../assets/js/global/disqus.js"></script>

    <footer>로딩중...</footer>
  </body>
</html>
